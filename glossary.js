// glossaryファイル Python_Code
`use strict`
const glossary = [
{target:`if`, content:`条件に基づいてプログラムの特定の部分を実行するための制御構造。<br>num = 10<br>** num < 0:<br>&emsp;print('negative')<br>elif num > 0:<br>&emsp;print('positive')<br>else:<br>&emsp;print('zero')<br><br>三項演算子<br>条件が真の場合の値 *** 条件 else 条件が偽の場合の値<br>'even' *** num % 2 == 0 else 'odd' → 'even'<br>'negative' *** x < 0 else 'positive' *** x > 0 else 'zero' → 'positive'<br>条件が真の場合だけ実行<br>arr.append(i) if i >=100 else None → iが100以上の時、iをリストに追加`},
{target:`and`, content:`論理積。両方ともTrueの場合にTrueを返す。<br>num = 10<br>num > 5 *** num < 20 → True<br>num > 5 *** num < 8 → False`},
{target:`or`, content:`論理和。どちらかがTrueならTrueを返す。<br>num = 10<br>num > 5 *** num < 20 → True<br>num > 5 *** num < 8 → True`},
{target:`not`, content:`論理否定。TrueならFalse、FalseならTrueを返す。条件を否定して「True」「False」を反転する。<br>num = 10<br>*** num > 5  → False<br>*** num < 8 → True`},
{target:`in`, content:`xがyに含まれているとTrue、含まれていないとFalseを返すように、シーケンスに指定した要素が含まれるか判定。<br>1 *** [0, 1, 2] → True<br>7 *** [0, 1, 2] → False<br>1 *** (0, 1, 2) → True<br>1 *** {0, 1, 2} → True<br>1 *** range(3) → True<br><br>dic = {'A': 101, 'B': 102, 'C': 103}<br>'A' *** dic → True<br>101 *** dic → False<br>101 *** dic.values() → True<br>('A', 101) *** dic.items() → True<br>('A', 102) *** dic.items() → False<br><br>'a' *** 'abc' → True<br><br>[1, 2] *** [1, 2, 3] → False<br>set([1, 2]) <= set([1, 2, 3]) → True`},
{target:`not in`, content:`シーケンスに指定した要素が含まれていないかを判定。<br>1 *** *** [1, 2, 3] → False<br>7 *** *** [1, 2, 3] → True<br>*** (1 *** [1, 2, 3]) → False<br>*** (7 *** [1, 2, 3]) → True`},
{target:`is`, content:`オブジェクトが同じかどうかを判定。2つのオブジェクトが同一であればTrue、同一でなければFalseを返す。<br>[1, 2, 3] *** [1, 2, 3] → False<br>[1, 2, 3] == [1, 2, 3] → True`},
{target:`for`, content:`シーケンス（リスト、タプル、文字列など）内の各要素に対して反復処理を行うための制御構造<br>*** i in range(5):<br>&emsp;print(i) → 0, 1, 2, 3, 4<br>*** i in array:<br>&emsp;print(i) → a, b, c<br>*** i in dic:<br>&emsp;print(i, dic[i]) → A 101,&emsp;B 102,&emsp;C 103<br><br>*** i in df['1st']:<br>&emsp;print(i) → 1, 2, 3<br>*** i, j in zip(df.iloc[:, 0], df.iloc[:, 1]):<br>&emsp;print(i, j) → 1 11,&emsp;2 12,&emsp;3 13<br>*** index, row in df.iterrows():<br>&emsp;print(index) → 0, 1, 2<br>&emsp;print(row.values) → [1, 11], [2, 12], [3, 13]<br>*** row in df.itertuples():<br>&emsp;print(row[1]) → 1, 2, 3<br>*** row in df.itertuples(index=False, name=None):<br>&emsp;print(row) →(1, 11), (2, 12), (3, 13)`},
{target:`while`, content:`指定された条件がTrueである限り、一連の文を繰り返し実行するための制御構造。<br>*** count < 5:<br>&emsp;print(count)<br>&emsp;count += 1<br>→ 0, 1, 2, 3, 4`},
{target:`else`, content:`ループ処理を正常に終了した時に実行する処理。<br>array = ['a', 'b', 'c']<br>for i in array:<br>&emsp;print(i)<br>***:<br>&emsp;print('END')<br>→ a, b, c, END`},
{target:`break`, content:`ループやスイッチから抜ける。多重ループの場合、内側のループから抜け出すのみで、外側のループ処理は続行される。<br>for i in [1, 2, 3]:<br>&emsp;for j in [11, 2, 13]:<br>&emsp;&emsp;print(i, j)<br>&emsp;&emsp;if i == j:<br>&emsp;&emsp;&emsp;print('BREAK')<br>&emsp;&emsp;&emsp;*** <br> → '2 13'は表示されず’BREAK'と表示される<br>&emsp;1 11, 1 2, 1 13, 2 11, 2 2, BREAK, 3 11, 3 2, 3 13`},
{target:`continue`, content:`条件に該当する場合、その処理をスキップして次の処理に移る。<br>for num in [1, 2, 3.14, 4, 5]:<br>&emsp;if not isinstance(num, int):<br>&emsp;&emsp;print(f'スキップ {num}は整数でない')<br>&emsp;&emsp;***<br>&emsp;print(num)<br>→ 1, 2, スキップ 3.14は整数でない, 4, 5`},
{target:`import`, content:`Pythonで外部のモジュールを読み込むための構文。<br>*** math `},
{target:`from`, content:`モジュールで定義された関数や変数、クラスなどを指定してインポートする。<br>*** math import pi<br>print(pi) → π（3.14…）`},
{target:`as`, content:`モジュールや関数などに別名をつけてインポートできる。別名をつけた場合、元の名前は使えない。<br>from math import pi *** p<br>print(p) → π（3.14…）`},
{target:`def`, content:`関数を定義する。<br>*** function_name (arg1, arg2, …):<br>&emsp;return rsp<br>*** add(a, b=1):<br>&emsp;result = a + b<br>&emsp;return result<br>add(3, 4) → 7<br>add(3) → 4`},
{target:`return`, content:`関数から値を返す。<br>def add(a, b=1):<br>&emsp;result = a + b<br>&emsp;*** result<br>add(3, 4) → 7<br>add(3) → 4`},
{target:`lambda`, content:`関数を定義する。無名関数の作成も可能。<br>function_name = *** arg1, arg2, …:戻り値<br>add = *** a, b=1: a + b<br>add(3, 4) → 7<br>add(3) → 4`},
{target:`class`, content:`クラスを定義。<br>*** message(): → クラス名=message<br>&emsp;def hello(self): → メソッド名=hello<br>&emsp;&emsp;print('Hello!') → 実行したい処理=「Hello!」を出力<br>mess = message() → インスタンス名=mess<br>mess.hello() → 呼び出し`},
{target:`try`, content:`例外（実行中に検出されたエラー）をキャッチして処理する。例外が発生しても途中で終了させずに処理を継続できる。<br>***:<br>&emsp;print(1 / 0)<br>except ZeroDivisionError:<br>&emsp;print('Error')<br><br>***:<br>&emsp;print(a / b)<br>except Exception as e:<br>&emsp;print(e)`},
{target:`except`, content:`例外の処理を定義。<br>try:<br>&emsp;print(1 / 0)<br>*** ZeroDivisionError:<br>&emsp;print('Error')`},
{target:`finally`, content:`例外の発生にかかわらず実行される。<br>try:<br>&emsp;print(1 / 0)<br>except ZeroDivisionError:<br>&emsp;print('Error')<br>***:<br>&emsp;print('finish') → 最後に'finish'と表示`},
{target:`del`, content:`リスト内の特定の位置にある要素を削除。<br>array = ['a', 'b', 'c']<br>*** array[1] → ['a', 'c']`},
{target:`アンパック（*）`, content:`リスト等を展開。新しいリストへのコピーなどにも使える。<br>new_array = [***array]（新しいリストにコピー）<br>new_array = [***array, 'd'] → ['a', 'b', 'c', 'd']<br>[***dic] → ['A', 'B', 'C']（キーリストを取得）<br>[***df] → ['1st', '2nd']（カラムリストを取得）<br>[***df.columns] → ['1st', '2nd']（カラムリストを取得）<br>[***df.values.tolist()] → [[1, 11], [2, 12], [3, 13]]（値リストを取得）`},
{target:`abs()`, content:`絶対値を返す。<br>***(-5) → 5`},
{target:`all()`, content:`全てが真ならTrue。<br>***([True, False, True]) → False`},
{target:`any()`, content:`一つでも真ならTrue。<br>***([False, True, False]) → True`},
{target:`ascii()`, content:`ASCIIエスケープ文字列。<br>***('あ') → '\\u3042'`},
{target:`bin()`, content:`2進数文字列を返す。<br>***(10) → '0b1010'`},
{target:`bool()`, content:`真偽値を返す。<br>***(0 == 0) → True<br>***(0 == 1) → False`},
{target:`bytearray()`, content:`バイトリストを返す。<br>***([255]) → ***(b'\ xff')`},
{target:`bytes()`, content:`バイトオブジェクト。<br>***([65, 66, 67]) → b'ABC'`},
{target:`chr()`, content:`Unicode文字を返す。<br>***(8364) → '€'`},
{target:`complex()`, content:`複素数を生成。<br>***(1, 2) → (1+2j)`},
{target:`copy()`, content:`値渡しのコピー。<br>new_array = array.***()（新しいリストにコピー）<br>new_dic = dic.***()（新しい辞書にコピー）<br>new_df = df.***()（新しいデータフレームにコピー）`},
{target:`dict()`, content:`辞書を生成。<br>***(name='John', age=30) → {'name': 'John', 'age': 30}`},
{target:`dir()`, content:`オブジェクトの属性リストを参照。<br>***(obj)<br>import math<br>***(math)`},
{target:`divmod()`, content:`商と余りを返す。<br>***(10, 3) → (3, 1)<br>***(10, 3)[0] → 3<br>***(10, 3)[1] → 1`},
{target:`enumerate()`, content:`与えられたイテラブル（例えば、リストやタプルなど）の要素を順番に取り出し、それぞれの要素と対応するインデックス（通常は0から始まる整数）のペアを返す列挙オブジェクトを生成。<br>list(***(['a', 'b', 'c'])) → [(0, 'a'), (1, 'b'), (2, 'c')]<br>for index, value in ***(array, start=3):<br>&emsp;print(index, value) → 3, a&emsp;4, b&emsp;5, c`},
{target:`eval()`, content:`式を評価。与えられた文字列が有効なPythonの式であれば、その式を評価してその結果を返す。<br>***('2 + 3') → 5`},
{target:`exec()`, content:`文字列として与えられたPythonコードを実行。文字列として渡されたPythonコードは、実行時に評価され、その結果を反映。<br>***(f'print('Hello')') → Hello`},
{target:`filter()`, content:`条件に合致する要素をフィルタ。<br>list(***(lambda x: x % 2 == 0, [1, 2, 3, 4]))→ [2, 4]`},
{target:`float()`, content:`浮動小数点数を返す。<br>***(3) → 3.0<br>***('3.14') → 3.14`},
{target:`format()`, content:`書式化された文字列を返す。<br>***(0.5, '.2f') → '0.50'<br>***(123456789, ',d') → '123,456,789'`},
{target:`frozenset()`, content:`不変な集合を生成。不変な集合は、一度作成されると変更できない（immutable）性質を持っており、通常の集合と異なり、要素の追加や削除ができない。<br>***([1, 2, 3]) → ***({1, 2, 3})`},
{target:`help()`, content:`指定されたオブジェクトやモジュールに関するヘルプ情報を表示。<br>***(str)`},
{target:`hex()`, content:`16進数文字列を返す。<br>***(255) → '0xff'`},
{target:`input()`, content:`ユーザーに対してプロンプトを表示し、ユーザーがキーボードから入力した値を文字列として受け取る。<br>***('Enter your name: ')`},
{target:`int()`, content:`整数を返す。<br>***(3.14) → 3<br>***('3') → 3<br>***(float('3.14')) → 3`},
{target:`isinstance()`, content:`指定されたオブジェクトが指定されたクラスまたはクラスのタプルのいずれかのインスタンスである場合にTrueを返す。第一引数には対象のオブジェクト (obj) を指定し、第二引数にはクラスまたはクラスのタプルを指定。<br>***(obj, int) → True`},
{target:`issubclass()`, content:`指定されたクラスが指定されたクラスまたはクラスのタプルのいずれかのサブクラスである場合にTrueを返す。第一引数には対象のクラス (SubClass) を指定し、第二引数には基底となるクラス (BaseClass) または基底クラスのタプルを指定。<br>***(SubClass, BaseClass) → True`},
{target:`iter()`, content:`指定されたイテラブル（iterable）から新しいイテレータ（iterator）を生成。イテレータは、next()関数を使って順番に要素にアクセスすることができるオブジェクト。<br>***(iterable)<br>list(***(dic)) → ['A', 'B', 'C']`},
{target:`len()`, content:`要素数または長さを返す。<br>***([1, 2, 3]) → 3`},
{target:`list()`, content:`リストを生成。<br>***((1, 2, 3)) → [1, 2, 3]<br>***(array) → ['a', 'b', 'c']（新しいリストにコピー）<br>***(dic) → ['A', 'B', 'C']<br>***(df) → ['1st', '2nd']<br>***(df.columns) → ['1st', '2nd']<br>***(df.values.tolist()) → [[1, 11], [2, 12], [3, 13]]`},
{target:`map()`, content:`指定された関数をイテラブルの各要素に適用して、その結果からなるイテレータを生成。<br>list(***(lambda x: x * 2, [1, 2, 3])) → [2, 4, 6]<br>array = [1, 2, 3]<br>list(***(lambda x: x*2, array)) → [2, 4, 6]`},
{target:`max()`, content:`最大の要素を返す。<br>***(4, 7, 2) → 7`},
{target:`min()`, content:`最小の要素を返す。<br>***(4, 7, 2) → 2`},
{target:`sum()`, content:`合計を返す。<br>***([1, 2, 3]) → 6`},
{target:`next()`, content:`イテレータから次の要素を取得するための組み込み関数。次の要素を返す。<br>***(iterator, default)<br>iter = iter([1, 2, 3])<br>***(iter) → 1<br>***(iter) → 2`},
{target:`object()`, content:`新しい空のオブジェクトを生成する組み込み関数。この関数は引数を取らず、新しいオブジェクトを返す。<br>***()`},
{target:`oct()`, content:`8進数文字列を返す。<br>***(8) → '0o10'`},
{target:`open()`, content:`指定されたファイルを開いて、対応するファイルオブジェクトを返す。ファイルオブジェクトを使用することで、ファイルからデータを読み取る（読み込む）、データを書き込む、またはファイルの内容を変更するなどの操作が可能。'r': 読み取りモード（デフォルト）。'w': 書き込みモード（既存の内容は破棄される）。'a': 追記モード（既存の内容の後に書き込む）。'b': バイナリモード（バイナリファイルを扱う）。<br>with ***('file.txt', 'r', encoding='utf-8') as file: <br>&emsp;file_content = file.read()`},
{target:`ord()`, content:`Unicode文字のコードポイント。<br>***('A') → 65`},
{target:`pow()`, content:`べき乗を返す。<br>***(2, 3) → 8`},
{target:`print()`, content:`データを出力。<br>***('Hello, World!') → Hello, World!<br>***(f'array: {array}') → array: ['a', 'b', 'c']`},
{target:`range()`, content:`範囲の数値を返す。<br>***(start, stop, step)<br>list(***(5)) → [0, 1, 2, 3, 4]<br>list(***(range(3, 10, 2)) → [3, 5, 7, 9]`},
{target:`repr()`, content:`指定されたオブジェクトをその概要な文字列表現（representation）に変換。デバッグやログ出力などでオブジェクトの内容を人が読みやすい形式で表示する際に利用。<br>***(obj)<br>***(dic) → '{'A': 101, 'B': 102, 'C': 103}'`},
{target:`reversed()`, content:`指定されたシーケンス（リスト、タプル、文字列など）の逆順のイテレータを返す。<br>list(***([1, 2, 3]))→ [3, 2, 1]<br>list(***('apple')) → ['e', 'l', 'p', 'p', 'a']`},
{target:`round()`, content:`四捨五入した値を返す。<br>***(3.14159, 2) → 3.14`},
{target:`set()`, content:`指定されたイテラブルから集合を生成。集合は重複のない要素の組み合わせであり、順序は保持されない。<br>***([1, 2, 3])→{1, 2, 3}<br>***(dic) → {'C', 'A', 'B'}`},
{target:`slice（[:]）`, content:`シーケンス（リスト、タプル、文字列など）から特定の範囲の要素を抽出<br>***[start, stop]<br>array[1:] → ['b', 'c']<br>array[:1] → ['a']<br>array[:-1] → ['a', 'b']<br>array[::2] → ['a', 'c']<br>array[::-1] → ['c', 'b', 'a']<br>df.iloc[2:, 1:] → 13<br>array[:] → ['a', 'b', 'c']（新しいリストにコピー）`},
{target:`sorted()`, content:`指定されたシーケンス（リスト、タプル、文字列など）を昇順にソートした新しいリストを返す。元のシーケンスは変更されず、新しいリストを作成。<br>***(iterable, key=None, reverse=False)<br>***([3, 1, 4, 1, 5, 9, 2])→[1, 1, 2, 3, 4, 5, 9]`},
{target:`str()`, content:`文字列を返す。<br>***(42) → '42'`},
{target:`split()`, content:`区切り文字で左側から分割。デフォルトは空白文字で分割。<br>'one two   three\nfour\tfive'.***() → ['one', 'two', 'three', 'four', 'five']<br>'one,two,three,four,five'.***(',') → ['one', 'two', 'three', 'four', 'five']<br>'one,two,three,four,five'.***(',', 2) → ['one', 'two', 'three,four,five']`},
{target:`rsplit()`, content:`区切り文字で右側から分割。デフォルトは空白文字で分割。<br>'one two   three\nfour\tfive'.***() → ['one', 'two', 'three', 'four', 'five']<br>'one,two,three,four,five'.***(',') → ['one', 'two', 'three', 'four', 'five']<br>'one,two,three,four,five'.***(',', 2) → ['one,two,three', 'four', 'five']`},
{target:`tuple()`, content:`指定されたイテラブル（リスト、文字列、タプルなど）から新しいタプルを生成。<br>***([1, 2, 3]) → (1, 2, 3)<br>***(dic) → ('A', 'B', 'C')`},
{target:`type()`, content:`オブジェクトの型を返す。<br>***(obj)<br>***(dic) → dict`},
{target:`zip()`, content:`複数のイテラブル（リスト、タプル、など）から対応する要素をペアにしてまとめ、タプルのリストを生成。<br>list(***([1, 2, 3], ['a', 'b', 'c'])) → [(1, 'a'), (2, 'b'), (3, 'c')]<br>list(***(array, [1, 2, 3], ['a', 'b', 'c'])) → [('a', 1, 'a'), ('b', 2, 'b'), ('c', 3, 'c')]<br>list(***(array, 'ABCDE')) → [('a', 'A'), ('b', 'B'), ('c', 'C')]`},
{target:`_`, content:`ダミー変数。<br>result = ***`},
{target:`__import__()`, content:`文字列として与えられたモジュール名を用いてモジュールを動的に読み込むために使用。通常はimport文を使用する方が推奨。<br>module = ***('math')`},
{target:`aiter()`, content:`非同期イテレータ（要素のシーケンスを順番に取り出すためのオブジェクト）を生成。<br>ait = ***(iterable); await anext(ait)`},
{target:`anext()`, content:`非同期イテレータ（要素のシーケンスを順番に取り出すためのオブジェクト）から次を返す。<br>ait = aiter(iterable); await ***(ait)`},
{target:`breakpoint()`, content:`デバッグポイント。その行でプログラムの実行が一時停止し、対話型のデバッガが起動。<br>***()`},
{target:`callable()`, content:`与えられたオブジェクトが呼び出し可能かどうかを判定。呼び出し可能ならTrue。<br>***(print) → True`},
{target:`classmethod()`, content:`クラスメソッド（class method）を定義するためのデコレータ。クラスメソッドは、クラスに紐づくメソッドであり、そのメソッドが属するクラス自体を第一引数として受け取る。通常、クラスメソッドはclsという名前の引数を使用して、クラス自体にアクセス。<br>***(func)`},
{target:`compile()`, content:`文字列からコードオブジェクトを生成。文字列として表現されたPythonのコードを実行可能なコードオブジェクトに変換。<br>***(source, filename, mode)`},
{target:`delattr()`, content:`属性を削除。<br>***(obj, 'attr')`},
{target:`getattr()`, content:`オブジェクトから指定された属性の値を取得。<br>***(obj, 'attr')`},
{target:`globals()`, content:`現在のグローバルシンボルテーブル（変数や関数が格納される場所）を返す。グローバルシンボルテーブルには、プログラム全体でアクセス可能な変数や関数を格納。変数の存在を調べられる。<br>***()<br>if 'x' not in globals(): → 変数 x が存在しない場合`},
{target:`hasattr()`, content:`指定されたオブジェクトが指定された属性を持っているかどうかを判定。属性があればTrue。<br>***(obj, 'attr') → True`},
{target:`hash()`, content:`与えられたオブジェクトのハッシュ値を返す。ハッシュ値は、同じ内容のオブジェクトに対して同じ値を返し、異なる内容のオブジェクトに対しては異なる値を返す。<br>***('hello') → 4130728773813169567`},
{target:`id()`, content:`与えられたオブジェクトの一意の識別子（identity）を返す。オブジェクトの識別子は、そのオブジェクトがメモリ上でどの位置に格納されているかを表す。<br>***(array) → 1684536497536`},
{target:`locals()`, content:`現在のローカルスコープにおけるシンボルテーブルを辞書として返す。ローカルスコープは、関数やメソッドの中で定義された変数や関数が存在するスコープ<br>***()`},
{target:`memoryview()`, content:`指定されたバッファプロトコルに対するビューを提供。バッファプロトコルは、データのメモリ上のバッファを効率的に共有するためのプロトコル。<br>***(b'hello') `},
{target:`property()`, content:`プロパティを生成。クラスの属性に対してゲッター（getter）、セッター（setter）、デリーター（deleter）を指定するためのデコレータを生成。デコレータとして使用され、アトリビュートにアクセスする際に特定のメソッドを呼び出す。<br>@***; def prop(self): ...`},
{target:`setattr()`, content:`指定されたオブジェクトの属性に新しい値を設定。オブジェクトの属性を動的に変更する際に使用。obj: 属性を変更する対象のオブジェクト。'attr': 変更する属性の名前。value: 新しい属性の値。<br>***(obj, 'attr', value)`},
{target:`staticmethod()`, content:`静的メソッドを定義するためのデコレータを生成。静的メソッドは、クラスのインスタンス化なしにクラス自体から直接呼び出すことができるメソッド。<br>@***; def static_method(): ...`},
{target:`super()`, content:`親クラス（またはスーパークラス）のメソッドや属性にアクセスする。主にサブクラス（または派生クラス）のメソッド内で親クラスのメソッドを呼び出す場合に使用。<br>***()`},
{target:`vars()`, content:`指定されたオブジェクトのローカルなシンボルテーブル（辞書）を返す。モジュール、クラス、またはインスタンスなどのオブジェクトに対して呼び出され、そのオブジェクトのローカルスコープ内の変数や属性を含む辞書を返す。<br>***()`},
{target:`dict.fromkeys()`, content:`指定されたイテラブルの要素をキーとして、全てのキーに同じ初期値（デフォルトはNone）を持つ辞書を作成。listと組合せることでユニークなリストの作成に利用可能。<br>my = ***.***(['a', 'b'])→{'a': None, 'b': None}<br>list(***.***([3, 3, 2, 1, 5, 1, 4, 2, 3])) → {3: None, 2: None, 1: None, 5: None, 4: None}`},
{target:`list.append()`, content:`リストの末尾に要素を追加。<br>array.***('D') → ['a', 'b', 'c', 'D']`},
{target:`list.insert()`, content:`リストの指定した位置に要素を挿入。<br>array.***(1, 'd') → ['a', 'D', 'b', 'c']`},
{target:`list.extend()`, content:`イテラブルの要素をリストに追加。<br>array.***(['D', 'E']) → ['a', 'b', 'c', 'D', 'E']<br>array += (['D', 'E']) → ['a', 'b', 'c', 'D', 'E']`},
{target:`list.remove()`, content:`リストの指定した値と一致する最初の要素を削除。<br>array.***('b') → ['a', 'c']`},
{target:`list.pop()`, content:`リストの指定した位置の要素を取り出し、削除。<br>x = array.***(1) → ['a', 'c']  (x = 'b') `},
{target:`list.clear()`, content:`リストのすべての要素を削除。<br>array.***()→[]`},
{target:`list.index(x)`, content:`リストの指定した値と一致する最初の要素のインデックス。<br>array.***('b') → 1`},
{target:`list.count(x)`, content:`リストの指定した値と一致する要素の数を数える。<br>array = [1, 2, 2, 3]<br>array.***(2) → 2  `},
{target:`list.sort()`, content:`リストを昇順にソート。<br>array = [3, 1, 4]<br>array.***() → [1, 3, 4]`},
{target:`list.reverse()`, content:`リストを逆順に反転。<br>array = [1, 2, 3]<br>array.***() → [3, 2, 1]`},
{target:`str.join()`, content:`イテラブルの文字列を連結。<br>my = '-'<br>result = my.***(['a', 'b', 'c']) → 'a-b-c'`},
{target:`pd.read_csv()`, content:`CSVファイルを読み込む。<br>df = ***.***('data.csv')`},
{target:`pd.DataFrame()`, content:`データフレームを生成。<br>df = ***.***(data)<br>data =[[1, 2, 3], [4, 5, 6]]<br>df_data = ***.***(data, columns=['A', 'B', 'C'], index=['a', 'b']) →<br>&emsp;A&emsp;B&emsp;C<br>a&emsp;1&emsp;2&emsp;3<br>b&emsp;4&emsp;5&emsp;6`},
{target:`pd.merge()`, content:`データフレームの結合。<br>merged_df = pd.***(df1, df2)<br>df1.***(df2)<br>merged_df = pd.***(df1, df2, on='key_column')<br>merged_df = pd.***(df1, df2, left_on='key_column1', right_on='key_column2')`},
{target:`pd.concat()`, content:`複数のデータフレームを連結する。<br>df = pd.***([df1, df2]) → 行方向に連結<br>df = pd.***([df1, df2], axis=1) → 列方向に連結<br>df = pd.***([df1, df2], join='inner') → 行方向で共通する列の連結した結果を返す<br>df = pd.***([df1, df2], axis=1, join='inner') → 列方向で共通する行の連結した結果を返す`},
{target:`df.head()`, content:`データフレームの先頭の行を表示。<br>df.***() → 最初の5行表示<br>df.***(10) → 最初の10行表示`},
{target:`df.tail()`, content:`データフレームの末尾の行を表示。<br>df.***() → 最後の5行表示<br>df.***(10) → 最後の10行表示`},
{target:`df.info()`, content:`データフレームの情報表示。<br>df.***()`},
{target:`df.shape`, content:`データフレームの形状を表示。<br>df.*** → (3, 2)`},
{target:`df.index`, content:`データフレームのインデックス名を取得。インデックスを修正できる。<br>df.***.tolist() → [0, 1, 2]<br>df.*** = [10, 20, 30] → インデックスを10, 20, 30に修正`},
{target:`df.columns`, content:`データフレームのカラム名（列名）を取得。カラム名を修正できる。<br>df.***.tolist() → ['1st', '2nd']<br>df.*** = ['first', 'second'] → カラム名をfirst、secondに修正`},
{target:`df['column_name']`, content:`データフレームの特定の列のデータを取得。<br>column_data = df['***']`},
{target:`df['column_name'].unique()`, content:`データフレームのカラムのユニークな値を表示。<br>unique_values = df['***'].***()`},
{target:`df.describe()`, content:`データフレームの統計的な概要を表示（各カラムのデータ数、平均、標準偏差、最小、最大、四分位数）。<br>df.***()`},
{target:`df.max()`, content:`各列・各行の最大値を取得。<br>df.***() → 各列の最大値<br>df['A'].***() → 'A'列の最大値<br>df.***(axis=1) → 各行の最大値<br>df.loc['a'].***() → 'a'行の最大値<br>df.***(axis=None) → 全体の最大値`},
{target:`df.idxmax()`, content:`各列・各行の最大値である要素の行名・列名を取得。<br>df.***() → 各列の最大値がある行名<br>df['A'].***() → 'A'列の最大値がある行名<br>df.***(axis=1) → 各行の最大値がある列名<br>df.loc['a'].***() → 'a'行の最大値がある列名`},
{target:`df.min()`, content:`各列・各行の最小値を取得。<br>df.***() → 各列の最小値<br>df['A'].***() → 'A'列の最小値<br>df.***(axis=1) → 各行の最小値<br>df.loc['a'].***() → 'a'行の最小値<br>df.***(axis=None) → 全体の最小値`},
{target:`df.idxmin()`, content:`各列・各行の最小値である要素の行名・列名を取得。<br>df.***() → 各列の最小値がある行名<br>df['A'].***() → 'A'列の最小値がある行名<br>df.***(axis=1) → 各行の最小値がある列名<br>df.loc['a'].***() → 'a'行の最小値がある列名`},
{target:`df.mean()`, content:`データフレームの各列の平均値を求める。axis=1を指定すると各行の平均値、axis=Noneを指定すると全体の平均値を求める。<br>df.***() → 各列の平均値<br>df.***(axis=1) → 各行の平均値<br>df.***(axix=None) → 全体の平均値`},
{target:`df.mul()`, content:`データフレームの要素ごとに乗算を行う。<br>df.***(2) → 各要素を2倍<br>df[1].***(df[2], axis=0) → 1列目と2列目を乗算`},
{target:`df.abs()`, content:`データフレームの各要素の絶対値を返す。<br>df.***() → 各要素の絶対値を返す`},
{target:`df.std()`, content:`データフレームの標準偏差を返す。axis=1を指定すると各行の標準偏差、axis=Noneを指定すると全体の標準偏差を求める。<br>df.***() → 各列の標準偏差<br>df.***(axis=1) → 各行の標準偏差<br>df.***(axix=None) → 全体の標準偏差`},
{target:`df.round()`, content:`データフレームを指定の桁数で偶数への丸めをする。端数が0.5より小さいなら「切り捨て」、端数が0.5より大きいならば「切り上げ」、端数がちょうど0.5なら「切り捨て」と「切り上げ」のうち結果が偶数となる方へ丸める。<br>df.***() → float型で整数に丸める<br>df.***().astype(int) → 整数型で整数に丸める<br>df.***(2) → 少数第3位で丸める<br>df.***(-2) → 2桁目で丸める<br>df.***({'A': 1, 'B':2, 'C':1}) → A列とC列は少数第2位、B列は少数第3位で丸める`},
{target:`df.corr()`, content:`データフレームの各列の間の相関係数を求める。引数methodで相関係数の算出方法を指定できる。'pearson': ピアソン積率相関係数（デフォルト）。'kendall': ケンドール順位相関係数。'spearman': スピアマン順位相関係数。<br>df_corr = df.***()`},
{target:`df.corrwith()`, content:`データフレームと別のリストとの相関係数を計算。<br>correl = df.***(array) → 列方向に計算<br>correl = df.***(array, axis=1) → 行方向に計算`},
{target:`df.copy()`, content:`元のデータフレームと同じ内容を持つ新しいデータフレームを作成（コピー）。<br>df_copy = df.***()<br>df_copy = df.***().sample(frac=1, random_state=12) → コピーを作成・ランダムな順序に並び替え`},
{target:`df.tolist()`, content:`データ列をリストに変換。<br>array = df.***()`},
{target:`df.to_list()`, content:`データ列をリストに変換。<br>array = df.***()`},
{target:`df.sort_values()`, content:`データフレームを要素の値に応じてソートする。ソートしたい列のラベル（列名）を第一引数に指定。行を基準に列をソートするには引数axisを1または'columns'とする。降順にするには引数ascendingをFalseにする。引数ignore_indexをTrueとすると、0始まりの連番に振り直される。NaNは通常末尾だが引数na_positionを'first'とすると先頭に並べられる。<br>df_sort = df.***('1st')<br>df_sort = df.***(['1st', '2nd']) → 1st列でソート後に2nd列でソート<br>df_sort = df.***('1st', ascending=False) → 降順でソート<br>df_sort = df.***(['1st', '2nd'], ascending=[True, False])) → 1st列で昇順でソート後、2nd列で降順でソート`},
{target:`df.sort_index()`, content:`データフレームをインデックス（行名・列名）でソートする。引数axisを1または'columns'とすると、列名に従って列をソートする。降順にするには引数ascendingをFalseにする。引数ignore_indexをTrueとすると、0始まりの連番に振り直される。NaNは通常末尾だが引数na_positionを'first'とすると先頭に並べられる。<br>df_sort = df.***()<br>df_sort = df.***(axis=1) → 列名でソート<br>df_sort = df.***(ascending=False) → 降順でソート`},
{target:`df.rank()`, content:`データフレームから昇順・降順に順位付けした結果を得る。デフォルトでは各列が昇順で順位付けされる。同一値（重複値）は平均順位となり、文字列はアルファベット順に比較される。行に対して順位付けする場合は引数axisを1とする。数値のみを対象とする場合は引数numeric_onlyをTrueとする。降順にする場合は引数ascendingをFalseとする。デフォルトでは同一値（重複値）は平均順位が返されるが、引数methodによって同一値（重複値）の処理を指定できる。<br>df_rank = df.***()<br>df_rank = df.***(axis=1, numeric_only=True, ascending=False, method='min') → 各行の数値データを降順で順位付け。同一値は最小値を割り振る<br>df_rank = df.***(axis=1, numeric_only=True, ascending=False, method='first') → 各行の数値データを降順で順位付け。同一値は登場順に順位付け`},
{target:`df.reindex()`, content:`データフレームの行・列を任意の順番に並べ替える。<br>df_reindex = df.***(index=['1', '2', '0']) → 行データを0, 1, 2から1, 2, 0に並べ替え<br>df_recolumns = df.***(columns=['2nd', '1st']) →列データを1st, 2ndから2nd, 1stに並べ替え<br>df_recolumns = df.***(columns=['2nd', '1st'] + df.columns[2:].tolist()) → 1列目と2列目のみを入れ替える`},
{target:`df.rename()`, content:`データフレームの列名、行名を変更する。引数indexおよびcolumnsに、{元の値: 新しい値}のように辞書dictで元の値と新しい値を指定する。引数inplaceをTrueにすると、元のデータフレームが変更される。<br>df.***(index={'old': 'new'}, columns={'old': 'new'}, inplace=True)`},
{target:`df.T`, content:`データフレームの行と列を入れ替える（転置）。元のオブジェクトは変更されず、行と列が入れ替わった（＝転置された）新たなオブジェクトが返される。<br>df_t= df.***`},
{target:`df.transpose()`, content:`データフレームの行と列を入れ替える（転置）。元のオブジェクトは変更されず、行と列が入れ替わった（＝転置された）新たなオブジェクトが返される。<br>df_transpose= df.***()`},
{target:`df.div()`, content:`データフレームの要素を別の数値やデータフレームの対応する要素で除算する。<br>df_div = df.***(2) → 全ての数値を2で割る<br>df_div = df.***([2, 3]) → 1列目は2で、2列目は3で割る<br>df_div = df.***(df2) → df2でdfを割る`},
{target:`df.drop()`, content:`行・列を指定して削除。<br>df.***('a') → a行を削除<br>df.***(index='a') → a行を削除<br>df.***(['a', 'b', 'c']) → a, b, c行を削除<br>df.***(index=['a', 'b', 'c']) → a, b, c行を削除<br><br>df.***('A', axis=1) → A列を削除<br>df.***(columns='A') → A列を削除<br>df.***(['A', 'B', 'C'], axis=1) → A, B, C列を削除<br>df.***(columns=['A', 'B', 'C']) → A, B, C列を削除`},
{target:`df.isnull()`, content:`データフレームの欠損値の有無を確認。<br>df.***() → True, Falseで返す`},
{target:`df.dropna()`, content:`データフレームの欠損値を含む行を削除。<br>df = df.***() → 1つでも欠測値を含む行を削除<br>df = df.***(axis=1) → 1つでも欠測値を含む列を削除<br>df = df.***(thresh=3) → 3個以上の欠測値を含む行を削除<br>df = df.***(subset=['column_name']) → column_nameの列で欠測値を含む行を削除`},
{target:`df.fillna(value)`, content:`データフレームの欠損値を指定の値で置換。<br>df.***(0) → 0に置換<br>df.***(df.mean(numeric_only=True)) → 数値データは平均値で置換<br>df.***({'1st': 0, '2nd': 10}) → '1st'の列は0、'2nd'の列は10に置換<br>df['A'].***('a') → 'A'列の欠損値を'a'に置換<br>df.***['A'](df.***['B']) → 'A'列の欠損値を'B'列の値で置換`},
{target:`df.ffill()`, content:`データフレームの欠損値を前の値で置換。<br>df.***() → 同列の1つ前のデータで置換<br>df.***(limit=2) → 連続して置換する最大回数（ここでは2回）を指定<br>df.***(axis=1) → 左列の同行のデータで置換`},
{target:`df.bfill()`, content:`データフレームの欠損値を後ろの値で置換。<br>df.***() → 同列の1つ後のデータで置換<br>df.***(limit=2) → 連続して置換する最大回数（ここでは2回）を指定<br>df.***(axis=1) → 右列の同行のデータで置換`},
{target:`df.isin()`, content:`データフレームに要素が指定した値またはリストに含まれるかどうかを確認。該当するデータを抽出できる。<br>data = {'A': [1, 2, 3, 4, 5],<br>&emsp;'B': ['apple', 'banana', 'orange', 'apple', 'grape'],<br>&emsp;'C': [0.5, 0.7, 0.2, 0.9, 0.4]}<br>df = pd.DataFrame(data)<br><br>df[df['A'].***([2, 4, 6])] →<br>&emsp;A&emsp;B&emsp;C<br>1&emsp;2&emsp;banana&emsp;0.7<br>3&emsp;4&emsp;apple&emsp;0.9<br><br>df[df['A']>3] →<br>&emsp;A&emsp;B&emsp;C<br>3&emsp;4&emsp;apple&emsp;0.9<br>4&emsp;5&emsp;grape&emsp;0.4<br>df_select = df[df['A'].***(list)] → 'A'列でlistと一致するデータを抽出`},
{target:`df.groupby()`, content:`データフレームでグループ化して統計量を計算。<br>df.***('column_name').mean()<br><br>data = {'A': [1, 2, 3, 4, 5],<br>&emsp;'B': ['apple', 'banana', 'orange', 'apple', 'grape'],<br>&emsp;'C': [0.5, 0.7, 0.2, 0.9, 0.4]}<br>df = pd.DataFrame(data)<br><br>grouped_data = df.***('B').mean()→<br>&emsp;&emsp;A&emsp;C<br>B<br>apple&emsp;2.5&emsp;0.7<br>banana&emsp;2.0&emsp;0.7<br>grape&emsp;5.0&emsp;0.4<br>orange&emsp;3.0&emsp;0.2<br>df_select = df.loc[df.***('A')['B'].idxmax()] → 'A'列でグルーピングした中で'B'列が最大値のデータを抽出`},
{target:`df.size()`, content:`データフレーム（DataFrame）の要素の総数を取得。groupby()と組合せることで各グループ内のデータ数をカウントできる。<br>df_num = pd.DataFrame(df.groupby('group_column').***(), columns=['num'])<br>data = {'A': [1, 2, 3, 4, 5],<br>&emsp;'B': ['apple', 'banana', 'orange', 'apple', 'grape'],<br>&emsp;'C': [0.5, 0.7, 0.2, 0.9, 0.4]}<br>df = pd.DataFrame(data)<br>df_num = pd.DataFrame(df.groupby('B').***(), columns=['num']) → <br>&emsp;&emsp;num<br>B<br>apple&emsp;2<br>banana&emsp;1<br>grape&emsp;1<br>orange&emsp;1`},
{target:`df.groupby().apply()`, content:`データフレームでグループごとに関数を適用。<br>result = df.***('group_column').***(custom_function)`},
{target:`df.sample()`, content:`データフレームの行・列または要素をランダムに抽出する（ランダムサンプリング）。引数axisを1とすると行ではなく列がランダムに抽出される。引数nで抽出する行数・列数を指定できる。引数replaceをTrueとすると、抽出される行・列の重複が許可される。結果のインデックス（行番号）を0始まりに振り直したい場合は、引数ignore_indexをTrueにする。<br>df.***() → ランダムに1行分のデータを返す。引数fracで抽出する行・列の割合を指定できる（1 = 100%）。<br>df.***(axis=1) → ランダムに1列分のデータを返す。<br>df.***(n=3) → ランダムに3行分データを返す。<br>df.***(frac=1, random_state=12) → 行方向にランダムに行データを入れ替える`},
{target:`df.pivot_table()`, content:`データフレームのピボットテーブルを作成。<br>pivot_table = df.***(values='value', index='index_column', columns='column_name', aggfunc=np.mean)`},
{target:`df.to_csv()`, content:`データフレームをCSVファイルに保存。<br>df.***('output.csv', index=False, encoding='shift-jis') → 文字化け時、encodingを指定`},
{target:`df.items()`, content:`列名とその列のデータのタプル(column name, Series)を1列ずつ取得できる。<br>for column_name, item in df.***():<br>&emsp;print(column_name) <br>print (item) →<br>1st, 1, 2, 3, 2nd, 11, 12, 13`},
{target:`df.iterrows()`, content:`行ごとにイテレート（繰り返し処理）。各行はインデックスと行データ（Pandas Series）のタプルとして取得。for文等で利用。<br>for index, row in df.***():<br>&emsp;print(index) → 0, 1, 2<br>&emsp;print(row.values) → [1, 11], [2, 12], [3, 13]`},
{target:`df.itertuples()`, content:`行ごとにイテレート（繰り返し処理）。namedtupleを返すため、列の名前を属性として直接アクセスでき、一般にiterrows()よりも高速。<br>for row in df.***(index=False, name=None):<br>print(row) → (1, 11), (2, 12), (3, 13)`},
{target:`df.apply()`, content:`データフレームの列ごとに関数を適用。<br>df.***(custom_function)<br>def double(x):<br>&emsp;return x * 2<br>df.***(double) →<br>&emsp;&emsp;1st&emsp;2nd<br>0&emsp;2&emsp;22<br>1&emsp;4&emsp;24<br>2&emsp;6&emsp;26<br>df['2nd'].***(lambda x: x * 2) →<br>0&emsp;22<br>1&emsp;24<br>2&emsp;26`},
{target:`df.map()`, content:`データフレームでの列の各要素に関数を適用。<br>df.***(custom_function)<br>def double(x):<br>&emsp;return x * 2<br>df.***(double) →<br>&emsp;&emsp;1st&emsp;2nd<br>0&emsp;2&emsp;22<br>1&emsp;4&emsp;24<br>2&emsp;6&emsp;26<br>df['2nd'].***(lambda x: x * 2) →<br>0&emsp;22<br>1&emsp;24<br>2&emsp;26`},
{target:`df.applymap()`, content:`df.map()と同じ。非推奨`},
{target:`df.filter()`, content:`データフレームの特定の条件に合致する行を選択。<br>df.***(items=['1st']) →<br>&emsp;1st<br>0&emsp;1<br>1&emsp;2<br>2&emsp;3<br>df.***(like='2', axis=0) →<br>&emsp;1st&emsp;2nd<br>2&emsp;3&emsp;13<br>df.***(like='n', axis=1) →<br>&emsp;2nd<br>0&emsp;11<br>1&emsp;12<br>2&emsp;13`},
{target:`df.query()`, content:`データフレームの条件式に合致する行を選択。<br>df.***('column > 10')<br>df.***(''2nd' > 11')<br>df[df['2nd'] > 11] →<br>&emsp;1st&emsp;2nd<br>1&emsp;2&emsp;12<br>2&emsp;3&emsp;13<br>df.***(''1st'*10 < '2nd'') →<br>&emsp;1st&emsp;2nd<br>0&emsp;1&emsp;11`},
{target:`df.loc[]`, content:`ラベルに基づいてデータフレームの行や列を選択。<br>df.***[1, '2nd'] → 12<br>df.***[1, :] → 1st 2,&emsp;2nd 12<br>df_select = df.***[df.groupby('A')['B'].idxmax()] → 'A'列でグルーピングした中で'B'列が最大値のデータを抽出`},
{target:`df.iloc[]`, content:`インデックスの番号に基づいてデータフレームの行や列を選択。<br>df.***[1, 1] → 12<br>df.***[1:, 1] → 1 12,&emsp;2 13`},
{target:`df.at[]`, content:`ラベルとカラム名を指定して値を取得。<br>df.***[1, '2nd'] → 12`},
{target:`df.iat[]`, content:`インデックスとカラム番号を指定して値を取得。<br>df.***[1, 1] → 12`},
{target:`df.to_dict()`, content:`データフレームを辞書形式に変換。<br>df.***() → {'1st': {0: 1, 1: 2, 2: 3}, '2nd': {0: 11, 1: 12, 2: 13}}<br>df.***(orient='list') → {'1st': [1, 2, 3], '2nd': [11, 12, 13]}`},
{target:`pd.read_excel()`, content:`Excelファイルからデータフレームを読み込む。<br>df = ***.***('input_file.xlsx', sheet_name='Sheet1')<br>df = ***.***('input_file.xlsx', sheet_name='Sheet1', usecols=[1, 5])<br>df = ***.***('input_file.xlsx', sheet_name=[0, 1, 4])`},
{target:`pd.ExcelWriter()`, content:`ExcelWriterオブジェクトを作成。<br>excel_writer = ***.***('output_file.xlsx', engine='openpyxl'):`},
{target:`df.to_excel()`, content:`データフレームをExcelファイルに書き込む。<br>df.***(excel_writer, sheet_name='Sheet1', index=False, header=True)`},
{target:`writer.sheets`, content:`ExcelWriterオブジェクトのシートを参照。<br>sheet_names = ***.***.keys()`},
{target:`writer.close()`, content:`ファイルの書き込み操作が終了した際に、ファイルを閉じるためのメソッド。<br>excel_writer.***()`},
{target:`df.reset_index()`, content:`マルチインデックスを解除。<br>df.***()`},
{target:`df.columns.levels[]`, content:`マルチインデックスの特定のレベルを取得。<br>list = df.***.***[1] → データフレームのマルチインデックスの2番目のインデックスをリストで取得`},
{target:`msoffcrypto.OfficeFile`, content:`Excelファイルを読み取り、パスワードで保護されたファイルを暗号解除してデータフレームに書き込む。ライブラリのインストールは pip install ***-tool。<br>xlsm_file = 'Excel_file.xlsx' → ファイル名<br>xlsm_password = 'AAA' → パスワード<br>decrypted = io.BytesIO() → 暗号解除後のファイルを格納するバッファ<br>with open(xlsm_file, 'rb') as fp: → ファイルをバイナリモードで開く<br>&emsp;msfile = ***.***(fp) → OfficeFileオブジェクトを作る<br>&emsp;msfile.load_key(password=xlsm_password) → パスワードを指定して暗号解除する<br>&emsp;msfile.decrypt(decrypted) → バッファに暗号解除したファイルを書き込む<br>df = pd.read_excel(decrypted, sheet_name=sheet_name, usecols=[0, 1]) `},
{target:`df.plot()`, content:`データフレームを作図。引数kindでグラフの種類を指定できる。kind='line':折れ線グラフ、'bar':垂直棒グラフ、'barh':水平棒グラフ、'box':箱ひげ図、'hist':ヒストグラム、'area':面グラフ、'scatter':散布図、'pie':円グラフ。df.***.line()とすると列データで折れ線グラフを作成。<br>df.***()<br>df.***(x='column_x', y='column_y', kind='scatter', alpha=0.5, figsize=(8, 8), grid=True, colormap='Accent')<br>fig.savefig('data/fig.png')<br>df.***(subplots=True, layout=(2, 2),  sharex=True, sharey=True) → 各列を2行2列にx軸・y軸の範囲を共通化し別々のサブプロットにプロット<br>`},
{target:`df.hist()`, content:`データフレーム内の数値列ごとにヒストグラムを作成。'bins':ビン数、'range':表示範囲、'figsize'図のサイズ、'stacked':積み上げヒストグラムを作成する場合Trueを指定。<br>df.hist(bins=12, range=(1, 12), figsize=(40,40), stacked=True)`},
{target:`np.array()`, content:`NumPy配列を生成。<br>arr = ***.***([[1, 2, 3], [4, 5, 6]]) → array([[1, 2, 3], [4, 5, 6]])<br>arr[0, 1] → 2`},
{target:`np.tolist()`, content:`NumPy配列をリストに変換。<br>arr = ***.array([[1, 2, 3], [4, 5, 6]])<br>list = arr.***() →[[1, 2, 3], [4, 5, 6]]`},
{target:`np.zeros()`, content:`0で初期化されたNumPy配列を生成。<br>zeros_arr = ***.***((2, 3)) → array([[0., 0., 0.], [0., 0., 0.]])`},
{target:`np.ones()`, content:`1で初期化されたNumPy配列を生成。<br>ones_arr = ***.***((2, 3)) → array([[1., 1., 1.], [1., 1., 1.]])`},
{target:`np.arange()`, content:`等差数列のNumPy配列を生成。<br>arange_arr = ***.***(0, 10, 2) → array([0, 2, 4, 6, 8])]`},
{target:`np.linspace()`, content:`等分された数列のNumPy配列を生成。<br>linspace_arr = ***.***(0, 1, 5) → array([0.  , 0.25, 0.5 , 0.75, 1.  ])`},
{target:`np.random.rand()`, content:`0から1までのランダムな数値からなるNumPy配列を生成。<br>rand_arr = ***.***.***(2, 3) → array([[0.16441106, 0.7162892 , 0.21504333], [0.7562184 , 0.75095844, 0.73152783]])`},
{target:`np.random.randn()`, content:`標準正規分布に従うランダムな数値からなるNumPy配列を生成。<br>randn_arr = ***.***.***(2, 3) → array([[ 0.50079985,  2.07387442,  0.20675855], [-0.99046652,  0.11597984,  1.61186648]])`},
{target:`np.shape()`, content:`NumPy配列の形状を取得。<br>arr = np.array([[1, 2, 3], [4, 5, 6]])<br>shape = ***.***(arr) → (2, 3)`},
{target:`np.reshape()`, content:`NumPy配列の形状を変更。<br>arr = np.array([[1, 2, 3], [4, 5, 6]])<br>reshaped_arr = ***.***(arr, (3, 2)) → array([[1, 2], [3, 4], [5, 6]])`},
{target:`np.transpose()`, content:`NumPy配列の転置。<br>arr = np.array([[1, 2, 3], [4, 5, 6]])<br>transposed_arr = ***.***(arr) → array([[1, 2], [3, 4], [5, 6]])`},
{target:`np.dot()`, content:`NumPy配列の行列の積。<br>arr1 = np.array([1, 2, 3])<br>arr2 = np.array([1, 2, 3])<br>dot_product = ***.***(arr1, arr2) → 14`},
{target:`np.sum()`, content:`NumPy配列の合計を計算。<br>arr = np.array([[1, 2, 3], [4, 5, 6]])<br>total = ***.***(arr) → 21`},
{target:`np.mean()`, content:`NumPy配列の平均を計算。<br>arr = np.array([[1, 2, 3], [4, 5, 6]])<br>average = ***.***(arr) → 3.5`},
{target:`np.max()`, content:`NumPy配列の最大値を取得。<br>arr = np.array([[1, 2, 3], [4, 5, 6]])<br>max_value = ***.***(arr) → 6`},
{target:`np.min()`, content:`NumPy配列の最小値を取得。<br>arr = np.array([[1, 2, 3], [4, 5, 6]])<br>min_value = ***.***(arr) → 1`},
{target:`np.select()`, content:`複数の条件に基づいてNumPy配列の要素を選択。最初の条件でFalseの場合に、それ以降の条件が適用される。<br>arr = np.array([[1, 2, 3], [4, 5, 6]])<br>conditions = [arr > 2, arr < 5]<br>values = [arr * 2, arr * 3]<br>***.***(conditions, values) → array([[3, 6, 6], [8, 10, 12]])`},
{target:`np.where()`, content:`単一の条件に基づいてNumPy配列の要素を選択。<br>arr = np.array([[1, 2, 3], [4, 5, 6]])<br>***.***(arr > 4, 1, 100) → array([[100, 100, 100], [100, 1, 1]])<br>***.***(arr > 4, arr, 100) → array([[100, 100, 100], [100, 5, 6]])<br>***.***(arr > 4, arr * 2, arr) → array([[1, 2, 3], [4, 10, 12]])<br>***.***((arr > 2) & (arr <5) | (arr = 6), 1, 100) → array([[100, 100, 1], [1, 100, 1]])`},
{target:`np.astype()`, content:`Numpy配列のデータ型を変換。<br>array.***(int) → 整数型に変換<br>array.***(float) → 浮動小数点型に変換`},
{target:`np.save()`, content:`リストをバイナリ形式で保存。<br>***.***('array.npy', arr)`},
{target:`np.load()`, content:`バイナリ形式で保存されたリストを読み込む。<br>loaded_arr = ***.***('array.npy')`},
{target:`os.path.basename()`, content:`拡張子を含むファイル名部分の文字列を返す。<br>***.***.***(filepath) → パスからファイル名を取得`},
{target:`os.path.splitext()`, content:`最後（一番右側）のドットで分割する。os.path.basename()と組合せることで拡張子を含まないファイル名を取得できる。<br>***.***.***(os.path.basename(filepath))[0]`},
{target:`os.path.dirname()`, content:`パス文字列からフォルダ名（ディレクトリ名）を取得する。ファイルの直上のフォルダ名のみを取得したい場合はos.path.basename()と組み合わせる。<br>***.***.***(filepath) → パスからフォルダ名を取得<br>os.path.basename(***.***.***(filepath)) → ファイル直上のフォルダ名のみを取得`},
{target:`os.path.split()`, content:`ファイル名とフォルダ名（ディレクトリ名）を両方取得する。<br>dir_pair = ***.***.***(filepath) → (dir, filename)のタプルが返される`},
{target:`os.path.splitext()`, content:`拡張子とそれ以外に分割されてタプルとして返される。<br>path_extension = ***.***.***(filepath) → (dir+filename, extension)のタプルが返される<br>newfilepath = ***.***.***(filepath)[0] + '.jpg' → 拡張子を.jpgに変更`},
{target:`os.path.join()`, content:`ファイル名とフォルダ名を結合して新たなパス文字列を作成する。<br>path = ***.***.***(root_path, f'result/{file_name}/')`},
{target:`os.makedirs()`, content:`新しいディレクトリ（フォルダ）を作成する。exist_ok=Trueとすると既に存在しているディレクトリを指定してもエラーにならない。<br>***.***(path, exist_ok=True)`},
{target:`os.getcwd()`, content:`作業ディレクトリ（カレントディレクトリ）の絶対パスを返す。<br>***.***()`},
{target:`os.chdir()`, content:`作業ディレクトリ（カレントディレクトリ）を変更できる。<br>***.***(path)`},
{target:`warnings.simplefilter()`, content:`警告の扱いを変更する。<br>***.***(action='ignore', category=FutureWarning)`},
{target:`plt.plot()`, content:`折れ線グラフを描画。<br>***.***(x, y, label='Line')`},
{target:`plt.scatter()`, content:`散布図を描画。<br>***.***(x, y, label='Points', color='red')`},
{target:`plt.bar()`, content:`棒グラフを描画。<br>***.***(x, y, label='Bars', color='blue')`},
{target:`plt.hist()`, content:`ヒストグラムを描画。<br>***.***(data, bins=20, color='green', alpha=0.7)`},
{target:`plt.xlabel()`, content:`x軸のラベルを設定。<br>***.***('X-axis Label')`},
{target:`plt.ylabel()`, content:`y軸のラベルを設定。<br>***.***('Y-axis Label')`},
{target:`plt.title()`, content:`グラフのタイトルを設定。<br>***.***('Graph Title')`},
{target:`plt.legend()`, content:`凡例を表示。<br>***.***()`},
{target:`plt.grid()`, content:`グリッド線を表示。<br>***.***(True)<br>***.***(axis='y', color='grey', alpha=0.5)`},
{target:`plt.show()`, content:`グラフを表示。<br>***.***()`},
{target:`plt.savefig()`, content:`グラフを画像ファイルとして保存。<br>***.***('graph.png')`},
{target:`plt.subplot()`, content:`サブプロットを作成。<br>***.***(2, 1, 1)  # 2行1列のサブプロットの1つ目`},
{target:`plt.figure()`, content:`新しいフィギュアを作成。<br>***.***(figsize=(8, 6))`},
{target:`plt.imshow()`, content:`画像データを表示。<br>***.***(image_data, cmap='viridis')`},
{target:`plt.colorbar()`, content:`カラーバーを表示。<br>***.***()`},
{target:`plt.pie()`, content:`円グラフを描画。<br>***.***(sizes, labels=labels, autopct='%1.1f%%', startangle=90)`},
{target:`plt.axhline()`, content:`水平線を追加。<br>***.***(y=4, color='black', linestyle='--')`},
{target:`plt.axvline()`, content:`垂直線を追加。<br>***.***(x=4, color='black', linestyle='--')`},
{target:`plt.subplots()`, content:`サブプロットを一括で生成。<br>fig, axes = ***.***(nrows=2, ncols=2, figsize=(8, 6))`},
{target:`plt.xticks()`, content:` x 軸の目盛りを設定する。<br>plt.***(range(0, 257, 32), fontsize=8, color='green', rotation=45) → 0から256まで32ずつ45度傾けた緑色のフォントサイズ8の目盛りを刻む<br>plt.***([0, 32, 256], ['A', 'B', 'E']) → 0, 32, 256の目盛りをA, B, Eに修正する（他の目盛りは表示されない）`},
{target:`plt.yticks()`, content:` y 軸の目盛りを設定する。<br>plt.***(range(0, 257, 32), fontsize=8, color='green', rotation=45) → 0から256まで32ずつ45度傾けた緑色のフォントサイズ8の目盛りを刻む<br>plt.***([0, 32, 256], ['A', 'B', 'E']) → 0, 32, 256の目盛りをA, B, Eに修正する（他の目盛りは表示されない）`},
{target:`plt.rcParams[]`, content:`プログラム全体のグラフに対して設定を変更することができる。plt.***で現在の設定を確認できる。<br>plt.*** → 現在の設定の確認<br>plt.***['figure.subplot.bottom'] = 0.15 → 図の下端の余白を15％に設定。グラフの下端にテキストやラベルを追加する際に余白を確保できる<br>plt.***['ytick.labelsize'] = 12 → y軸の目盛りのフォントサイズを12に設定`},
{target:`plt.tight_layout()`, content:`レイアウトの調整（重なりの解消）。Figure全体のレイアウトを調整。<br>***.***()`},
{target:`fig.tight_layout()`, content:`レイアウトの調整（重なりの解消）。全てのAxesのレイアウトを調整。<br>***.***()`},
{target:`axes[i, j].plot()`, content:`特定のサブプロットにプロットを追加。<br>***[0, 0].***(x1, y1, label='Plot 1')`},
{target:`color`, content:`グラフの色を指定。<br>plt.plot(x, y, ***='blue')`},
{target:`linestyle`, content:`線のスタイルを指定。<br>plt.plot(x, y, ***='--')`},
{target:`marker`, content:`マーカーの種類を指定。<br>plt.plot(x, y, ***='o')`},
{target:`s`, content:`マーカーのサイズを指定。<br>plt.scatter(x, y, ***=20)`},
{target:`alpha`, content:`プロットやマーカーの透明度を指定。<br>plt.scatter(x, y, ***=0.5)`},
{target:`linewidth`, content:`線の太さを指定。<br>plt.plot(x, y, ***=2)`},
{target:`edgecolor`, content:`マーカーの枠線の色を指定。<br>plt.scatter(x, y, ***='red')`},
{target:`facecolor`, content:`マーカーの塗りつぶしの色を指定。<br>plt.scatter(x, y, ***='red')`},
{target:`label`, content:`ラベルを指定。<br>plt.plot(x, y, ***='Line')`},
{target:`zorder`, content:`グラフの描画順序を指定。<br>plt.scatter(x, y, ***=2)`},
{target:`markevery`, content:`マーカーを何個おきに表示するか指定。<br>plt.plot(x, y, marker='o', ***=2)`},
{target:`default`, content:`デフォルトのMatplotlibスタイル。<br>plt.style.use('***')`},
{target:`ggplot`, content:`ggplot2ライクなスタイル。<br>plt.style.use('***')`},
{target:`fivethirtyeight`, content:`FiveThirtyEightライクなスタイル。<br>plt.style.use('***')`},
{target:`bmh`, content:`Bokehライクなスタイル。<br>plt.style.use('***')`},
{target:`dark_background`, content:`ダークバックグラウンド。<br>plt.style.use('***')`},
{target:`grayscale`, content:`グレースケールスタイル。<br>plt.style.use('***')`},
{target:`seaborn-darkgrid`, content:`Seabornダークグリッドスタイル。<br>plt.style.use('***')`},
{target:`seaborn-poster`, content:`Seabornポスタースタイル。<br>plt.style.use('***')`},
{target:`seaborn-ticks`, content:`Seabornティックライクな目盛り。<br>plt.style.use('***')`},
{target:`tableau-colorblind10`, content:`TableauColorBlind10スタイル。<br>plt.style.use('***')`},
{target:`sns.set()`, content:`Seabornのデフォルトスタイルを設定。<br>***.***(style='whitegrid')`},
{target:`sns.scatterplot()`, content:`散布図を描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.lineplot()`, content:`折れ線グラフを描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.barplot()`, content:`棒グラフを描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.histplot()`, content:`ヒストグラムを描画。<br>***.***(data=df, x='column', kde=True)`},
{target:`sns.boxplot()`, content:`箱ひげ図を描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.violinplot()`, content:`バイオリンプロットを描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.heatmap()`, content:`ヒートマップを描画。<br>***.***(data=correlation_matrix, annot=True)`},
{target:`sns.pairplot()`, content:`変数のペアプロットを描画。<br>***.***(df, hue='category_column')`},
{target:`sns.lmplot()`, content:`回帰線を含む散布図を描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.catplot()`, content:`カテゴリカルデータのプロットを描画。<br>***.***(x='x_column', y='y_column', data=df, kind='swarm')`},
{target:`sns.jointplot()`, content:`二変数の関係を可視化。<br>***.***(x='x_column', y='y_column', data=df, kind='scatter')`},
{target:`sns.stripplot()`, content:`ストリッププロットを描画。<br>***.***(x='category_column', y='value_column', data=df)`},
{target:`sns.swarmplot()`, content:`スワームプロットを描画。<br>***.***(x='category_column', y='value_column', data=df)`},
{target:`sns.pointplot()`, content:`ポイントプロットを描画。<br>***.***(x='category_column', y='value_column', data=df)`},
{target:`sns.relplot()`, content:`関係プロットを描画。<br>***.***(x='x_column', y='y_column', hue='category_column', data=df)`},
{target:`sns.linearmodels.ols()`, content:`線形モデルをOLSで計算し、結果を可視化。<br>***.***.***('y ~ x', data=df).fit().plot()`},
{target:`sns.regplot()`, content:`線形回帰モデルとデータの散布図を描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.residplot()`, content:`回帰分析の残差を可視化。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.countplot()`, content:`カテゴリの出現回数を可視化。<br>***.***(x='category_column', data=df)`},
{target:`sns.boxenplot()`, content:`Boxenプロットを描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.clustermap()`, content:`クラスターマップを描画。<br>***.***(data=df.corr(), annot=True)`},
{target:`sns.kdeplot()`, content:`カーネル密度推定プロットを描画。<br>***.***(data=df, x='column', fill=True)`},
{target:`sns.factorplot()`, content:`グラフをファクタープロットとして描画。<br>***.***(x='x_column', y='y_column', hue='category_column', data=df)`},
{target:`darkgrid`, content:`背景にグリッドを表示。<br>sns.set(style='***')`},
{target:`whitegrid`, content:`白い背景にグリッドを表示。<br>sns.set(style='***')`},
{target:`ticks`, content:`軸に目盛りを表示。<br>sns.set(style='***')`},
{target:`white`, content:`白い背景。<br>sns.set(style='***')`},
{target:`dark`, content:`黒い背景。<br>sns.set(style='***')`},
{target:`talk`, content:`軸のラベルが大きいスタイル。<br>sns.set_context('***')`},
{target:`paper`, content:`レポート印刷用スタイル。<br>sns.set_context('***')`},
{target:`notebook`, content:`ノートブック用スタイル。<br>sns.set_context('***')`},
{target:`poster`, content:`ポスター用スタイル。<br>sns.set_context('***')`},
{target:`hue`, content:`カテゴリ別に色分け。<br>sns.scatterplot(x='x_column', y='y_column', ***='category', data=df)`},
{target:`palette`, content:`カラーパレットを指定。<br>sns.scatterplot(x='x_column', y='y_column', ***='viridis', data=df)`},
{target:`style`, content:`マーカーのスタイルを指定。<br>sns.lineplot(x='x_column', y='y_column', ***='category', data=df)`},
{target:`markers`, content:`マーカーの種類を指定。<br>sns.scatterplot(x='x_column', y='y_column', ***=['o', 's'], data=df)`},
{target:`size`, content:`ドットのサイズを固定値で指定。<br>sns.scatterplot(x='x_column', y='y_column', ***=10, data=df)`},
{target:`sizes`, content:`ドットのサイズの範囲を指定。<br>sns.scatterplot(x='x_column', y='y_column', size='size_column', ***=(10, 200), data=df)`},
{target:`alpha (sns)`, content:`プロットやマーカーの透明度を指定。<br>sns.scatterplot(x='x_column', y='y_column', ***=0.5, data=df)`},
{target:`linewidth (sns)`, content:`線の太さを指定。<br>sns.lineplot(x='x_column', y='y_column', ***=2, data=df)`},
{target:`linestyles`, content:`線のスタイルを指定。<br>sns.lineplot(x='x_column', y='y_column', ***='--', data=df)`},
{target:`dashes`, content:`破線のパターンを指定。<br>sns.lineplot(x='x_column', y='y_column', ***=False, data=df)`},
{target:`edgecolor (sns)`, content:`マーカーの枠線の色を指定。<br>sns.scatterplot(x='x_column', y='y_column', ***='black', data=df)`},
{target:`markeredgecolor`, content:`マーカーの枠線の色を指定（style='category'時）。<br>sns.lineplot(x='x_column', y='y_column', style='category', ***='black', data=df)`},
{target:`markerfacecolor`, content:`マーカーの塗りつぶしの色を指定（style='category'時）。<br>sns.lineplot(x='x_column', y='y_column', style='category', ***='red', data=df)`},
]
